#!/bin/sh


# cron task to push xqwhc property to server

. /lib/functions.sh
. /lib/xqwhc/xqwhc_hyt.sh
. /lib/xqwhc/xqwhc_metric.sh

export ROLE_CAP=0
export ROLE_RE=1
export ROLE_INV=2

PUSH_CAP_RELIST=1
DEBUG_XQWHC_PUSH=0

LOGI()
{
    local stderr=''
    if [ "$DEBUG_XQWHC_PUSH" -gt 0 ]; then 
        stderr='-s'
    fi   

    logger $stderr -p 1 -t "xqwhc_push" "$1"
}

__check_situation()
{
    # skip it in ft_mode
    [ 1 -eq `cat /proc/xiaoqiang/ft_mode` ] && return 1

    # skip if not init
    [ "YES" != "`uci -q get xiaoqiang.common.INITTED`" ] && return 2

    return 0
}

__setkv()
{
    matool --method setKV --params "$1" "$2" >/dev/null 2>&1 || {
        LOGI " matool setkv $1 $2 failed!"
    }
}

__if_whc_re()
{
    timeout -t 5 tbus -v list "$1" 2>/dev/null | grep -qE "whc_sync[:\",]+" || return 1
    return 0
}


__backhaul2bmp()
{
    local raw_bhs="$1"
    local __bmp=0
    #use reserved instead of ori plc
    for bb in 2g 5g eth; do
        list_contains raw_bhs $bb && {
            #0 between 5g and eth, remove plc
            [ $bb = "eth" ] && __bmp=$((__bmp | (1 << 0) ))
            local bit=`eval echo '$'BACKHAUL_BMP_$bb`
            __bmp=$((__bmp | (1 << $bit) ))
        }
    done

    eval "$2=$__bmp"
    [ -n "$__bmp" ]
}

xqwhc_push()
{

# handle push on CAP
if whcal iscap; then
    # role
    __setkv "whc_role" "$ROLE_CAP"


  # TODO get relist devid and mac
  if [ "$PUSH_CAP_RELIST" -gt 0 ]; then

    local re_list=""
    while read -r LINE
    do

#  CAP quire re whc info
#        root@XiaoQiang:/tmp# tbus call 192.168.31.127 whc_quire
#{
#        "wanmac": "50:64:2b:b5:81:31",
#        "backhauls": "7",
#        "devid": "829d713a-2c39-e37c-5ee9-dc5af9248138",
#        "return": "success"
#}
        [ -z "$LINE" ] && continue

        if [ "`parse_json "$LINE" return 2>/dev/null`" = "success" ];then
            re_devid="`parse_json "$LINE" devid`"
            re_mac="`parse_json "$LINE" wanmac`"

            # convert bhs to bmp
            bmp="`parse_json "$LINE" backhauls`"
            [ -z "$bmp" ] && bmp=0
            locale="`parse_json "$LINE" locale`"
            initted="`parse_json "$LINE" initted`"
            ip="`parse_json "$LINE" ip`"

            re_node="{\
\"devid\":\"$re_devid\",\
\"wanmac\":\"$re_mac\",\
\"backhauls\":\"$bmp\",\
\"locale\":\"$locale\",\
\"initted\":\"$initted\",\
\"ip\":\"$ip\"\
},"

            LOGI "   re node:$re_node"
            [ "0" = "$initted" ] && {
                LOGI "     re node NOT init-done, ignore push it!"
                continue
            }

            append re_list "$re_node"
        fi

    done < /tmp/xq_whc_quire

    re_list=${re_list%,}
    [ -n "$re_list" ] && __setkv "cap_whc_relist" "[$re_list]" || __setkv "cap_whc_relist" "[]"

  fi


elif whcal isre; then
    # role
    __setkv "whc_role" "$ROLE_RE"

    # self wanmac
    __setkv "re_whc_wanmac" "`getmac wan`"

    # upnode mac
    
    upnode="` xqwhc_metric_get_upstream | awk -F';' '{print $1}' `"
    [ -n "$upnode" ] && __setkv "re_whc_upnode" "$upnode"

    # RE backhauls
    whcal getmetric
    val=$?
    bh_bmp=$((val & 0xf))
    qa_bmp=$((val >> 4))
    [ -n "$bh_bmp" ] && {
        __setkv "re_whc_backhauls" "$bh_bmp"
        __setkv "re_whc_backhauls_qa" "$qa_bmp"
    }

    # CAP devid from tbus
    cap_devid="`uci -q get bind.info.remoteID`"
    [ -n "$cap_devid" ] && __setkv "re_whc_cap_devid" "$cap_devid"

    LOGI " RE push: up $upnode, bh:qa $bh_bmp:$qa_bmp, capdevid $cap_devid"

else
    LOGI " not cap/re, make sure init done!"
    __setkv "whc_role" "$ROLE_INV"
fi
}

# discrete push to reduce server overload
__discrete_delay()
{
    local span="$1"    # span round secs
    [ -z "$span" ] && span=100

    ## push avln info prop to server
    # delay some sec to scatter the presure to server
    local seed=`md5sum /proc/sys/kernel/random/uuid | awk -F- '{print $1}'`
    local raw=`printf %d 0x${seed:0:8}`
    local value=$((raw % span))
    sleep $value
}

__check_situation || exit $?
[ "$1" != "now" ] && __discrete_delay 100
xqwhc_push


