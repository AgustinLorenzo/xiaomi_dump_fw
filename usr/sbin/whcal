#!/bin/sh 

# support for bsp lower layer


. /lib/xqwhc/xqwhc_public.sh
#. /lib/xqwhc/xqwhc_init.sh
#. /lib/xqwhc/xqwhc_hyt.sh


# 1. add lock to insure thread-safe
LOCKF="/var/lock/xqwhc.lock"
ERR_WHC_LOCK=100
WHC_LOCK()
{
    lock "$LOCKF" 2>/dev/null
}

WHC_TRYLOCK()
{
    lock -n "$LOCKF" 2>/dev/null && lock -u "$LOCKF"
}

WHC_UNLOCK()
{
    lock -u "$LOCKF" 2>/dev/null
}


list="iscap isre role metric getmetric readmetric sync sync_lite syncbuf rawcheck totalcheck status recnt"
method="$1"
ret=0
out=""


trap "WHC_UNLOCK; exit 1" SIGINT SIGHUP SIGTERM SIGKILL SIGSEGV

#4. dispatch
case "$method" in
    iscap)
        . /lib/xqwhc/xqwhc_stat.sh
        xqwhc_is_cap
        ret=$?
        ;;

    isre)
        . /lib/xqwhc/xqwhc_stat.sh
        xqwhc_is_re
        ret=$?
        ;;

    role)
        . /lib/xqwhc/xqwhc_stat.sh
        echo -n "$(xqwhc_get_stat)"
        ret=0
        ;;

    status)
        . /lib/xqwhc/xqwhc_hyt.sh
        WHC_TRYLOCK || return $ERR_WHC_LOCK
        xqwhc_get_self_status
        ret=$?
        echo "$message"
        ;;

    sync)
        # sync with wifi cfg update
        . /lib/xqwhc/xqwhc_sync.sh
        WHC_LOCK
WHC_LOGI " ** whcal sync ppid=$PPID"
        xqwhc_sync
        ret=$?
        WHC_UNLOCK
        ;;

    sync_lite)
        # lite sync withOUT wifi update
        . /lib/xqwhc/xqwhc_sync.sh
        WHC_LOCK
WHC_LOGI " ** whcal sync_lite ppid=$PPID"
        xqwhc_sync_lite
        ret=$?
        WHC_UNLOCK
        ;;

    # for CAP: rawcheck to confirm init done
    # for RE: rawcheck to show that config is activate and service running
    rawcheck)
        . /lib/xqwhc/xqwhc_stat.sh
        WHC_TRYLOCK || return $ERR_WHC_LOCK
        xqwhc_rawcheck
        ret=$?
        ;;

    # unify check for CAP/RE. CAP equal rawcheck, RE equal to precise check
    totalcheck)
        . /lib/xqwhc/xqwhc_stat.sh
        WHC_LOGI "*totalcheck"
        #if WHC_TRYLOCK; then  # ignore lock in xqwhc init context
        if true; then
          xqwhc_rawcheck || return $?
          if xqwhc_is_re; then
              . /lib/xqwhc/xqwhc_hyt.sh
              #xqwhc_re_linkmetric
              #ret=$?
              #WHC_LOGI "xqwhc_re_linkmetric, ret=$ret"
              #xqwhc_gateway_ping
              #ret=$?
              #WHC_LOGI "xqwhc_gateway_ping, ret=$ret"
              xqwhc_assoc_check
              ret=$?
              WHC_LOGI "xqwhc_assoc_check, ret=$ret"
              ## Once init process done, use this to handle led timely.
              #[ "$ret" = "$ERR_METRIC_POOR" ] && {
              #  WHC_LOGI " warnning, link metric is poor!"
              #  ret="$ERR_METRIC_GOOD"
              #}
          fi
        else
            # get lock fail, xqwhc initting
            ret=$ERR_WHC_LOCK
        fi
        WHC_LOGI "*totalcheck, ret=$ret"
        ;;

    # link metrics
    metric)
        . /lib/xqwhc/xqwhc_hyt.sh
        WHC_TRYLOCK || return $ERR_WHC_LOCK
        xqwhc_re_linkmetric
        ret=$?
        res="$(xqwhc_metric_get_str)"
        echo -n "$res"
        ;;

    getmetric)
        [ "`uci -q get xiaoqiang.common.INITTED`" = "YES" ] || WHC_LOGI "*getmetric"
        . /lib/xqwhc/xqwhc_metric.sh
        xqwhc_metric_get_verbose
        ret=$?

        [ "`uci -q get xiaoqiang.common.INITTED`" = "YES" ] || WHC_LOGI "*getmetric res=0x`printf %x $ret`"
        ;;

    readmetric)
        . /lib/xqwhc/xqwhc_metric.sh
        str="$(xqwhc_metric_get_str)"
        ret=$?
        WHC_LOGI "*readmetric $str"
        echo -n "$str"
        ;;

    syncbuf)
        . /lib/xqwhc/xqwhc_sync.sh
        xqwhc_sync_jsonbuf
        ret=$?
        ;;

    initbuf)
        . /lib/xqwhc/xqwhc_sync.sh
        xqwhc_init_jsonbuf
        ret=$?
        ;;

    recnt)
        . /lib/xqwhc/xqwhc_hyt.sh
        cnt=$(xqwhc_get_recnt)
        ret=$cnt
        ;;

    *)
        echo " support cmd:" 
        echo "$0 $list"
        ret=1
    ;;
esac

return $ret

