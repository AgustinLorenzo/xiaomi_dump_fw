#!/bin/sh 

# xqwhc superv deamon
# 1. check link metric

. /lib/xqwhc/xqwhc.sh
. /lib/xqwhc/network_lal.sh

TIMEOUT=10
STEP_DELAY=15
STEP_DELAY_MIN=1
STEP_PLC_SPV=246
METRIC_SPAN=210

SON_LOG_DIR="/tmp/log"
PLOG_DIR="/data/usr/log/whc/"
MAX_LOG_SIZE=666000
DEBUG_XQWHC_SUPERV=0

metric_pre=""
pushed=0;
XQWHC_STATE="/tmp/run/.xqwhc_backhaul_superv"

BH_ETH=13
BH_NONETH=31

LOGI()
{
    [ "$DEBUG_XQWHC_SUPERV" -gt 0 ] && stdout="-s" || stdout=""
    logger $stdout -p 1 -t "xqwhc_superv" "$1"
}

######### begin xqwhc sync with repacd
__sync_lock_wait()
{
    # wait lock ctrl in repacd
    lock -w ${XQWHC_REPACD_SYNC_LOCK}_$2
}

# to check if argin iface is forece down by repacd
# 0: force_down=1
# 1: force_down=0
xqwhc_repacd_sync_ifdown_confirm()
{
    local ifn="$1"
    local val=""
    __sync_lock_wait $ifn
    val="`grep "${XQWHC_REPACD_IFDOWN}_${ifn}:" $XQWHC_REPACD_SYNC | awk -F: '{print $2}'`"
    [ -z "$val" ] && val=0

    if [ "$val" = "1"  ]; then
        LOGI " ** xqwhc_repacd_sync ${XQWHC_REPACD_IFDOWN}_${ifn} = [$val] "
        return 0
    else
        return 1
    fi
}

######### end xqwhc sync with repacd


# to checkout if hyd submodule set to expect log level
hyd_dbg_superv()
{    
    local info_list="pcService pcwService pcpService pceService"
    local none_list="wlanManager csh"
    local flag=0;

    levels="`(echo dbg s; sleep 2) | hyt`"
    [ -z "$levels" ] && {
        LOGI "  *** hyd modules not found, hyd MAY not running.."
        return 1
    }

    for mm in $info_list; do
        echo "$levels" | grep -iEq "^$mm.*info" && continue

        hyd_debug.sh dbg "$info_list" info > /dev/null 2>&1
        break
    done

    for mm in $none_list; do
        echo "$levels" | grep -iEq "^$mm.*none" && continue

        hyd_debug.sh dbg "$none_list" none > /dev/null 2>&1
        break
    done

    return 0;
}



metric_superv()
{
    whcal isre || return 0

        # precise check RE link state, ctrl led
        # metric will takes 5 secs to get result
        metric="`timeout -t $TIMEOUT whcal metric 2>/dev/null`"
        [ -z "$metric" ] && {
            LOGI " exception, whcal metric timeout no ret!"
            LOGI " @@@ `ps -w | grep lock | grep -v grep | grep -v kblockd`"
            lock -u /var/lock/xqwhc.lock
            return 0
        }

        [ "$metric_pre" != "$metric" ] && {
            LOGI "  metric <$metric_pre>to <$metric>, update led!"
            eval led_link_$metric

            metric_pre="$metric"
        }

        # if blue led is off, then clear pre to make sure work well on blue led on
        [ "$metric" = "good" ] && led_check && metric_pre=""
        
        [ "$metric" != "fail" -a "$pushed" -eq 0 ] && {
            sh /usr/sbin/xqwhc_push.cron now &
            pushed=1
        }
}


# qca wifison service log
# hyd log file wrap & tarback
son_log_superv()
{
    local list="${SON_LOG_DIR}/xqwhc.log"

    # if log file exceed size, then gzip it
    for ff in $list; do
        [ -f "$ff" ] || continue
        [ "`stat -c%s $ff`" -gt $MAX_LOG_SIZE ] && {
            cd $SON_LOG_DIR
            # get idx
            idx=$(ls -l $SON_LOG_DIR | grep "`basename $ff`.[0-9].tar.gz" -c)
            [ "$idx" -gt 9 ] && idx=0
            ffn="`basename $ff`.$idx"
            cp $ff $ffn
            #rm -f `basename $ffn`.tar
            tar -cf $ffn.tar $ffn
            gzip -f $ffn.tar
            rm -f $ffn.tar $ffn
            mv ${ffn}.tar.gz $PLOG_DIR
            echo > $ff 
            sync
            # echo -n "$ff" | grep -q hyd && ( /etc/init.d/hyd restart & ) # hyd.log rewind work in libhyficommon.so
            LOGI " ** `basename ${ff%.log}` log gzip and create new **  "
        }   
    done
}

# abandoned, just illustrate the ethbh get principle
__gateway_get()
{
    gate_ip=`route -n  | grep "^0.0.0.0" | awk '{print $2}'`
    gate_mac=`cat /proc/net/arp | grep "$gate_ip" | grep -Eo "..:..:..:..:..:.."`
    gate_bport=`brctl showmacs br-lan | grep "$gate_mac" | awk '{print $1}'`
    gate_if=`brctl showstp br-lan | grep "\($gate_bport\)"`
}

__gateway_ping()
{
    local gw_ip="$(nlal_get_gw_ip lan)"
    if [ -n "$gw_ip" ]; then
        ping $gw_ip -q -w $STEP_DELAY -c $STEP_DELAY 2>&1 >/dev/null &
    else
        LOGI "  NO find valid gateway!"
    fi
}


## superv backhaul
# 1. check daisychain
# 2. check ethbackhaul, bring down sta
backhaul_superv()
{
    local stalist=""
    local netw="lan"
    local ret=0
    nlal_get_wifi_staiface_bynet $netw stalist

    # check eth backhaul, gateway from eth
    if nlal_if_eth_bh_exist $netw; then
        echo "backhaul eth" > "$XQWHC_STATE"

        # down wifi backhauls
        for ff in $stalist; do
            nlal_check_sta_iface $ff && {
                nlal_disable_sta_iface $ff
                LOGI " find eth backhaul, wpa_cli bring DOWN wifi backhauls"
            }
        done

:<<!
        # WA eth-RE whc_dist to avoid RE below compose daisy-chain
        nlal_get_wifi_apiface_bynet $netw aplist
        for ff in $aplist; do
            dist="`iwpriv $ff get_whc_dist | awk -F: '{print $2}'`"
            [ "$dist" -le 2 ] && {
                LOGI " set eth-RE $ff whc_dist>2"
                iwpriv $ff set_whc_dist 3
            }
        done
!
        ret=$BH_ETH
    else
        echo "backhaul NON eth" > "$XQWHC_STATE"

        # up wifi backhauls
        #   but be care of conflict in repacd wifimon
        for ff in $stalist; do
            nlal_check_sta_iface $ff || {
                xqwhc_repacd_sync_ifdown_confirm $ff && {
                    LOGI " NON-eth backhaul, but wifi backhaul $ff bring down by repacd, ignore"
                } || {
                    nlal_enable_sta_iface $ff
                    LOGI " *NON-eth backhaul, wpa_cli bring UP wifi backhauls"
                }
            }
        done

        ret=$BH_NONETH
    fi

    return $ret
}

main()
{
    period=$STEP_DELAY
    mkdir -p "$PLOG_DIR"

    while true; do

        boot_status="$(cat /proc/xiaoqiang/boot_status 2>/dev/null)"
        [ "$boot_status" = "3" ] || {
            sleep 1
            continue
        }

        [ "YES" = "`uci -q get xiaoqiang.common.INITTED`" ] || {
            sleep 1
            continue
        }


        # re processing
        [ "$(($period % $STEP_DELAY))" -eq 0 ] && {
            # re ONLY
            whcal isre && {
                __gateway_ping
                backhaul_superv
                metric_superv
            }
        }

        # log
        [ "$period" -ge "$STEP_PLC_SPV" ] && {
            period=0
            son_log_superv
            hyd_dbg_superv
        }

        period=$((period + 1))
        sleep 1
        continue
    done
}

# link metric on RE without WHCLOCK
# this should be called right after init_re
metric_superv_rt()
{
    . /lib/xqwhc/xqwhc_hyt.sh
    . /lib/xqwhc/xqwhc_metric.sh
    local start="`cat /proc/uptime | awk -F. '{print $1}'`"
    local now=$start
    local metric
    
    while true; do
        now="`cat /proc/uptime | awk -F. '{print $1}'`"
        [ "$((now - start))" -gt "$METRIC_SPAN" ] && break

        #LOGI "      realtime metric processing... "
        #WHC_LOGI "      realtime metric processing... "
        xqwhc_re_linkmetric
        ret=$?

        metric="$(xqwhc_metric_get_str)"
        LOGI "      realtime metric $metric "
        WHC_LOGI "      realtime metric $metric "

    # store metric files to debug
    {
        local tdir="$XQWHC_METRIC_RT"
        mkdir -p "${tdir}"
        local fn="${tdir}/`basename ${XQWHC_METRIC_BUFF}`-`date +%H%M%S`"
        cp ${XQWHC_METRIC_BUFF} $fn
    }

        if [ "`uci -q get xiaoqiang.common.INITTED`" != "YES" ]; then
            continue
        fi
        
        [ "$metric_pre" != "$metric" ] && {
            LOGI "  realtime metric <$metric_pre>to <$metric>, update led!"
            eval led_link_$metric
            metric_pre="$metric"
        }

        [ "metric" != "fail" -a "$pushed" -eq 0 ] && {
            sh /usr/sbin/xqwhc_push.cron now &
            pushed=1
        }
    done

    LOGI " realtime metric span out!"
    return 0
}

[ "$1" = "rtmetric" ] && {
    LOGI " launch a realtime metric superv!"
    metric_superv_rt
    exit 0
}

main

